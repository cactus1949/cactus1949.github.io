{"meta":{"title":"浅见寡识","subtitle":"how much can i do?","description":"How much can i do?","author":"CACTUS","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-11-06T06:11:11.796Z","updated":"2020-11-06T06:11:11.796Z","comments":false,"path":"Links/index.html","permalink":"http://yoursite.com/Links/index.html","excerpt":"","text":""},{"title":"about","date":"2020-07-06T07:37:14.000Z","updated":"2020-09-08T01:10:19.097Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"about me知者减半，省者全无"},{"title":"文章标签","date":"2017-05-27T05:47:40.000Z","updated":"2020-10-27T10:30:39.868Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2017-05-27T05:47:40.000Z","updated":"2020-10-27T10:31:15.011Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"记迁移mongodb数据库","slug":"mongodb数据库迁移","date":"2021-06-05T09:10:51.940Z","updated":"2021-06-05T09:53:24.329Z","comments":true,"path":"2021/06/05/mongodb数据库迁移/","link":"","permalink":"http://yoursite.com/2021/06/05/mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%81%E7%A7%BB/","excerpt":"","text":"记迁移mongodb数据库 在写CM的过程中，因为一些数据来自官方，且随着时间推移，官方数据库不再存储该数据，所以需要进行保存到自建的服务器上，在这个过程中，我练手的服务器无法代替正式上线的服务器，这里就需要到了迁移 迁移分两步，备份与恢复 备份首先在原来的服务器上进行对数据库的备份操作： mongodump -h dbhost -d dbname -o dbdirectory -h：MongoDB 所在服务器地址 -d：需要备份的数据库实例 -o：备份的数据存放位置这里我执行的是：mongodump -h 127.0.0.1:27017 -d cocmanage-test -o /root/dump大概意思是，将本服务器上的cocmanage-test数据库实例的数据备份到/root/dump下到这里备份工作完成了 恢复将上一步中的dump文件传到新的服务器上，为了方便也可以上传到root文件夹下执行 mongorestore -h &lt;hostname&gt;&lt;:port&gt; -d dbname &lt;path&gt; --host &lt;:port&gt;, -h &lt;:port&gt;：MongoDB所在服务器地址 --db , -d ：需要恢复的数据库实例 --drop：恢复的时候，先删除当前数据，然后恢复备份的数据。 &lt;path&gt;：mongorestore 最后的一个参数，设置备份数据所在位置，这里我执行的是mongorestore -h xx.xx.xx.xx:27017 -d cocmanage-test /root/dump/ --drop大概意思是，将/root/dump的数据 恢复到xx.xx.xx.xx:27017下mongodb中，数据库实例名称为cocmanage-test","categories":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/categories/mongodb/"},{"name":"后端","slug":"mongodb/后端","permalink":"http://yoursite.com/categories/mongodb/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"},{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"Nodejs常用模块记录","slug":"Nodejs常用模块记录","date":"2020-11-18T10:54:07.496Z","updated":"2020-11-18T11:10:37.668Z","comments":true,"path":"2020/11/18/Nodejs常用模块记录/","link":"","permalink":"http://yoursite.com/2020/11/18/Nodejs%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97%E8%AE%B0%E5%BD%95/","excerpt":"","text":"Nodejs常用模块记录querystringget请求中，会把请求参数链入url中，产生的叫query，querystring用来对query进行一些操作 下载并引入//终端下下载 npm i --save querystring //app.js const querystring = require(&#39;querystring&#39;);querystring.escape()格式：querystring.escape(string) 传入一个string作为参数，返回转义后的结果 querystring.escape(&#39;id=1&#39;);//id%3D1querystring.unescape()格式：querystring.unescape(string) 和.escape()正好相反，可以将上面示例中转义后的结果传入.unescape()中 querystring.unescape(&#39;id%3D1&#39;);//id=1querystring.parse()格式：querystring.parse(string) 传入一个字符串，返回一个对象，反序列化 querystring.parse(&#39;type=1&amp;status=0&#39;);//{ type: &#39;1&#39;, status: &#39;0&#39; }querystring.stringify()格式：querystring.stringify(obj) 传入一个对象，将对象序列化 let obj = { type: 1, status: 0 } querystring.stringify(obj);//type=1&amp;status=0","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"},{"name":"模块","slug":"node/模块","permalink":"http://yoursite.com/categories/node/%E6%A8%A1%E5%9D%97/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"模块","slug":"模块","permalink":"http://yoursite.com/tags/%E6%A8%A1%E5%9D%97/"},{"name":"querystring","slug":"querystring","permalink":"http://yoursite.com/tags/querystring/"}]},{"title":"常见koa中间件","slug":"常用koa中间件","date":"2020-11-16T07:13:17.734Z","updated":"2020-11-19T03:08:04.668Z","comments":true,"path":"2020/11/16/常用koa中间件/","link":"","permalink":"http://yoursite.com/2020/11/16/%E5%B8%B8%E7%94%A8koa%E4%B8%AD%E9%97%B4%E4%BB%B6/","excerpt":"","text":"常见koa中间件koa-bodyparser将post请求的参数解析道ctx.request.body中 const bodyparser = require(&#39;koa-parser&#39;); const koa = require(&#39;koa&#39;); const app = new koa(); app.use(bodyparser());//加载中间件 post请求处理中 let postdata = ctx.request.body//可以获取到请求的参数koa-compose将多个中间件整合为一个中间件，方便重用或导出。 const koa = require(&#39;koa&#39;); const app = new koa(); const compose = require(&#39;koa-compose&#39;); async function middleware1(ctx,next){ console.log(&#39;one start&#39;);//1 await next(); console.log(&#39;one end&#39;);//6 } async function middleware2(ctx,next){ console.log(&#39;two start&#39;);//2 console.log(&#39;three end&#39;);//3 await next(); } async function middleware3(ctx,next){ console.log(&#39;three start&#39;);//4 await next(); console.log(&#39;three end&#39;);//5 } const all = compose([middleware1,middleware2,middleware3]); app.use(all) app.listen(3000)koa-static文件服务器中间件，用来处理静态资源，依赖于另一款中间件koa-send。 当HTTP请求到达服务器后，koa-static对请求进行判断，对于符合要求的get请求和put请求，会调用koa-send加载并进行响应。 const static = require(&#39;koa-static&#39;); app.use(static(__dirname+&#39;/static&#39;));/static存放静态资源 koa-router自建一个路由组件 完成功能： 只支持处理get请求 //router.js class Router{ constructor(){ this._routes = []; } get(url,handler){ this._routes.push({ url: url, method: &#39;GET&#39;, handler }) } routes(){ return async (context,next)=&gt;{ const {method,url} = context; //使用es6中的解构赋值获取method以及url值 const matchroute = this._routes.find(r =&gt; r.method === method &amp;&amp; r.url === url) if(matchroute &amp;&amp; matchroute.handler){ await matchroute.handler(context,next); }else{ await next(); } } } } module.exports = new Router(); //index.js const koa = require(&#39;koa&#39;); const router = require(&#39;./router&#39;);//加载自定义路由组件 const app = new koa(); app.use(router.routes());//使用路由组件返回的中间件 router.get(&#39;/404&#39;,(ctx,next)=&gt;{ ctx.body = &#39;404 page not found&#39;; ctx.status = 404; }) app.listen(3000) 在之前接触到的ctx.type以及ctx.method，虽然可以通过这两个属性进行路由的实现，但是实在是冗余不方便阅读 以下是登陆的一个小demo： //引入模块 const koa = require(&#39;koa&#39;); const app = new koa(); const Router = require(&#39;koa-router&#39;);//引入koa-router const router = new Router()；//初始化router const bodyparser = require(&#39;koa-bodyparser&#39;); app.use(bodyparser()); router.get(&#39;/login&#39;,(ctx,next)=&gt;{//定义路径为&#39;/login&#39;的路由规则 let html = ` &lt;form method=&quot;POST&quot; action=&quot;/login&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;username&quot;&gt;&lt;/input&gt; &lt;input type=&quot;password&quot; id=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;password&quot;&gt;&lt;/input&gt; &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt; &lt;/form&gt; `; ctx.response.body = html; console.log(&#39;login index&#39;) }) router.post(&#39;/login&#39;,(ctx,next)=&gt;{ let html = ` HELLO ${ctx.request.body.username} `; console.log(ctx.request.body);//这里想要获取到post请求的内容，需要借助koa-parser中间件 ctx.response.body = html; console.log(&#39;login in&#39;) }) app.use(router.routes()).use(router.allowedMethods());//通过use方法注册路由中间件 app.listen(3000) router自带的方法const Router = require(&#39;koa-router&#39;); const router = new Router();.getget请求 参数： 路由 回调函数，匹配路由后执行 参数ctx：上下文 next：调用则执行下一个中间件 //router.get(url,handler); router.get(&#39;/&#39;,(ctx,next)=&gt;{ ctx.body = &#39;hello&#39; }).postpost请求 //router.post(url,handler); router.post(&#39;/api/login&#39;,(ctx,next)=&gt;{ const user = ctx.request.body; //这里获取ctx.request.body需要bodyparser ctx.body = { user: user } }).deldelete请求 //router.del(url,handler); router.del(&#39;/posts/:pid&#39;,(ctx,next)=&gt;{ //delete pid === ctx.params.pid 的文章 ctx.body = &#39;delete successfully&#39; }).putput请求 .all当路由匹配一致并且在其他method中间件中有运行yield，那么就会执行method为all的中间件 router.get(&#39;/&#39;,async (ctx,next)=&gt;{ //... yield; }) router.all(&#39;/&#39;,async (ctx,next)=&gt;{ //... })其他用法命名路由嵌套路由访问/forums/:fid/posts/:pid获取某篇文章接口、/forums/:fid/posts获取某个板块列表 const Router = require(&#39;koa-router&#39;); const forums = new Router(); const posts = new Router(); posts.get(&#39;/&#39;,(ctx,next)=&gt;{...}) posts.get(&#39;/:pid&#39;,(ctx,next)=&gt;{...}) forums.use(&#39;/forums/:fid/posts&#39;,posts.routes(),posts.allowedMedthods()); app.use(forums.routes());多个中间件路由前缀url参数koa-views用来加载HTML模版的中间件 //koa-view-test.js const views = require(&#39;koa-views&#39;); const path = require(&#39;path&#39;); app.use(views(path.join(__dirname,&#39;./views&#39;),{ extension: &#39;ejs&#39; })) ...router或app.use之中，加载模版 let title = &#39;koa-view-test&#39;; ctx.render(&#39;index&#39;,{title});//传入模版的数据//这里不写后缀默认为ejs文件 // /views/index.ejs &lt;%= title %&gt;","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"},{"name":"node","slug":"FE/node","permalink":"http://yoursite.com/categories/FE/node/"},{"name":"服务端框架","slug":"FE/node/服务端框架","permalink":"http://yoursite.com/categories/FE/node/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"koa","slug":"koa","permalink":"http://yoursite.com/tags/koa/"}]},{"title":"node的修行--第四天","slug":"node的修行--第四天","date":"2020-11-16T00:34:58.573Z","updated":"2020-11-16T07:13:45.113Z","comments":true,"path":"2020/11/16/node的修行--第四天/","link":"","permalink":"http://yoursite.com/2020/11/16/node%E7%9A%84%E4%BF%AE%E8%A1%8C--%E7%AC%AC%E5%9B%9B%E5%A4%A9/","excerpt":"","text":"node的修行–第四天 koa与Node.js开发实战 koa简介官网介绍，koa是下一代nodejs的web框架，在前面示例中，有使用到express，两者同宗，都是web框架，express主要采用es5的语法，一般使用回调函数处理异步操作，koa1和koa2分别支持es6中的generator函数+yield语句+promise以及es7中的async/await+promise处理异步操作 需要补充知识： es6 generator函数 es7 async/await promise 上下文(context)在koa每个use中，都有着与之对应的一个上下文context，他保存着两个对象：request对象，response对象 上下文获取方式： 函数参数ctx const koa = require(&#39;koa&#39;); const app = new koa(); app.use((ctx)=&gt;{ ctx.response.body = { method: ctx.request.method, url: ctx.request.url, } }) app.listen(3000,()=&gt;{ console.log(&#39;is listening port 3000&#39;) }) this 这里如果使用this获取Context，那么就不能使用箭头函数 const koa = require(&#39;koa&#39;); const app = new koa(); app.use(function*(){ this.response.body = { method: this.request.method, url: this.request.url, } }) app.listen(3000,()=&gt;{ console.log(&#39;is listening port 3000&#39;) }) 以下示例中全部使用函数参数ctx方式获取context ctx常用apictx.statue这是一个命名空间，在中间件之间传递消息，以及将信息传递到模版，无需直接向ctx添加属性避免命名冲突 ctx.cookies获取cookie ctx.cookies.get(name,[options]) 设置cookie ctx.cookie.set(name,value,[options]) ctx.throw抛出一个错误 ctx.throw(500)request对象api 请求对象 ctx.request//获取到的是koa的request对象 ctx.req//获取到的是node的request对象 koa的request对象是在nodejs的请求对象之上的抽象 ctx.request.method请求方式 ctx.request.url请求地址 ctx.request.path请求路由 ctx.request.accepts()客户端期望收到的数据类型 response对象api 响应对象 ctx.response ctx.response.body响应体 一般会将需要传递的数据添加到响应体中 ctx.response.type显式设置Content-Type ctx.response.status请求状态 ctx.response.is(type..)用于检查响应类型是否是所提供的类型之一 ctx.response.redirect(url,[alt])重定向 将状态码为302的请求重定向到url上 例如登陆后自动重定向到网站的首页 get/post请求处理const koa = require(&#39;koa&#39;); const app = new koa(); app.use(ctx=&gt;{ ctx.response.body = { url: ctx.request.url, query: ctx.request.query,//get请求参数 querystring: ctx.request.querystring } }) app.listen(3000,()=&gt;{ console.log(&#39;is listening port 3000&#39;) })koa中没有封装获取post请求，可以通过nodejs原生提供的Request对象进行获取(ctx.req) const koa = require(&#39;koa&#39;); const app = new koa(); app.use(ctx=&gt;{ let postdata = &#39;&#39;; ctx.req.on(&#39;data&#39;,(data)=&gt;{ postdata += data; }) ctx.req.on(&#39;end&#39;,()=&gt;{ console.log(postdata); }) }) app.listen(3000,()=&gt;{ console.log(&#39;is listening port 3000&#39;) })显而易见，这种方法十分不方便，类似于express中的body-parser，koa也有对应的中间件koa-bodyparser koa-bodyparser会将post请求的参数解析到ctx.request.body上 const bodyparser = require(&#39;koa-bodyparser&#39;); const koa = require(&#39;koa&#39;); const app = new koa(); app.use(bodyparser());//加载中间件 app.use(async ctx=&gt;{ ctx.response.body = { data: ctx.request.body } }) app.listen(3000,()=&gt;{ console.log(&#39;is listening port 3000&#39;) })使用curl：curl --data &quot;username=cactus&quot; http://127.0.0.1:3000/可以得到响应：{&quot;data&quot;:{&quot;username&quot;:&quot;cactus&quot;}}","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"},{"name":"node","slug":"FE/node","permalink":"http://yoursite.com/categories/FE/node/"},{"name":"服务端框架","slug":"FE/node/服务端框架","permalink":"http://yoursite.com/categories/FE/node/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"koa","slug":"koa","permalink":"http://yoursite.com/tags/koa/"}]},{"title":"node的修行--第三天","slug":"node的修行--第三天","date":"2020-11-12T13:03:53.081Z","updated":"2020-11-16T00:35:31.489Z","comments":true,"path":"2020/11/12/node的修行--第三天/","link":"","permalink":"http://yoursite.com/2020/11/12/node%E7%9A%84%E4%BF%AE%E8%A1%8C--%E7%AC%AC%E4%B8%89%E5%A4%A9/","excerpt":"","text":"node的修行–第三天 示例出自nodejs实战(第二版)第三章 get到的新模块 Tips: 1.安装模块：在项目目录下，打开terminal，输入npm install –save 模块名 这样默认安装的是最新的模块版本 –save：添加这个参数是默认配置到packet.json中的dependencies下，不用手动配置，后续使用npm install可以下载相关依赖 2.引入模块：const 模块名 = require(‘模块名’) ​ 如果是自己编写的模块，需要写相对路径 express 需要补充的过多，需要另外开单一章节去详细说明，这里只记录在示例中使用到 这里是一个简易的示例 //index.js const express = require(&#39;express&#39;);//引入express模块 const app = new express();//通过express模块创建一个实例 app.get(&#39;/&#39;,(req,res)=&gt;{//使用get方法访问请求127.0.0.1:3000/ res.send(&#39;Hello!&#39;) }) app.listen(3000,()=&gt;{ console.log(&#39;is listening port 3000&#39;) })使用node index.js运行后，可以在命令行看到is listening port 3000，在浏览器中访问127.0.0.1:3000/可以看到Hello! //除了app.get() app.post(&#39;/articles&#39;,(req,res,next)=&gt;{//post请求 接口为/articles res.send(req.body.id);//req.body需要body-parser模块才可以获取到 }) //method为delete的请求 //作用：删除id为url中参数的文章 app.delete(&#39;/articles/:id&#39;,(req,res,next)=&gt;{//这里:id表示传入的参数 res.send(req.params.id); })以上示例中，参数req，res分别表示为request、response，有很多对应的方法 //1. 发送http响应 res.send(&#39;Hello&#39;); //2. 通过请求头的类型，返回对应的格式 res.format({ html: ()=&gt;{ res.render(&#39;.ejs&#39;,参数...) } json: ()=&gt;{ res.send(&#39;HELLO&#39;) } }) //3. 设置响应头的信息 res.setHeader(&#39;key&#39;,&#39;value&#39;) //4. 设置响应的HTTP状态 res.status(code);//这里code为http状态码body-parser body-parser原来是express模块中的功能之一，因为功能过多，所以移出，产生了单独的模块 主要用于获取post请求中请求体的内容 top-level middleware//引入模块 const bodyParser = require(&#39;body-parser&#39;); //添加通用的json和urlencoded解析器作为顶级中间件，该中间件将解析所有传入请求的主体 app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended:true})); //使用 app.post(&#39;/&#39;,(req,res)=&gt;{ res.send(req.body) })the most recommended//引入模块 const bodyParser = require(&#39;body-parser&#39;); //创建解析器 var jsonParser = bodyParser.json(); var urlencodedParser = bodyParser.urlencoded({extended: true}); //使用 app.post(&#39;/&#39;,jsonParser,(req,res)=&gt;{ res.send(req.body) })type for parsers//引入模块 const bodyParser = require(&#39;body-parser&#39;); const express = require(&#39;express&#39;); const app = express(); //传入不同的type值，创建不同的中间件 //将不同的自定义json类型解析为json app.use(bodyParser.json({type: &#39;application/*+json&#39;})); //将一些自定义的内容解析为二进制buffer格式 app.use(bodyParser.raw({ type: &#39;application/vnd.custom-type&#39; })) //将html解析为字符串 app.use(bodyParser.text({type: &#39;text/html&#39;}));sqlite3 数据库相关 引入sqlite3const sqlite3 = require(&#39;sqlite3&#39;).verbose(); Versos 冗长的 这里是执行模式设置为冗长，以产生较长的stack traces（栈跟踪/堆栈回溯）。 数据库创建并连接数据库创建后默认会在本地根目录下创建一个文件 const dbname = &#39;sqlite3.later&#39;;//设置数据库名 const db = new sqlite3.Database(dbname); //创建数据库 //可以传入第二个参数，为回调函数，用于错误处理，示例如下 const db = new sqlite3.Database(dbname,(err)=&gt;{ if(err){ return console.error(err.message); } console.log(&#39;Connected to the in-memory SQlite database.&#39;); })sqlite3.Database()第一个参数除了可以写数据库名之外，还可以写相对路径，设置数据库名并设置了数据库存放的位置。 第二个参数是可选参数，有三种值，表示的是连接数据库的方式 sqlite3.OPEN_READONLY:打开数据库为只读 sqlite3.OPEN_READWRITE:打开数据库进行读写 sqlite3.OPEN_CREATE:打开数据库，如果数据库不存在，则创建一个新的数据库 关闭数据库连接db.close();可以传入一个参数，为回调函数，回调函数有一个参数是err表示错误信息，如下 db.close((err)=&gt;{ if(err){ return console.error(err.message); } console.log(&#39;Close the database connection.&#39;); })数据库操作相关 运行sql语句 db.run(&#39;create table ...&#39;);//参数为sql语句 node-readability 这个模块可以将任何web页面转换为clean view 在本示例中，使用它将web页面转换为clean view后，获取页面的title以及content值进行保存 //引入 const read = require(&#39;node-readability&#39;); //使用 app.post(&#39;/articles&#39;,(req,res,next)=&gt;{ //这里获取到post提交上来的url值，需要body-parser模块 const url = req.body.url; read(url,(err,results)=&gt;{ if(err) res.status(500).send(&#39;Error downing articles&#39;); //获取正常后的操作 }) })bootstrap使用express.static中间件引入css文件 // index.js app.use(bodyParser.json()); app.use(bodyParser.urlencoded({extended: true})); app.use(&#39;/css&#39;, express.static(__dirname + &#39;/node_modules/bootstrap/dist/css&#39;));前两句代码请点击跳转 tips上述代码中__dirname为当前文件夹的目录，相同的还有 __filename:当前文件的目录 遇到的知识点补充curlcurl是一种命令行工具，用来请求web服务器。 在这次示例中，使用到的有 //get请求 curl http://127.0.0.1:3000/articles //post请求，--data后面的是post的请求体 curl --data &quot;username=cactus&quot; http://127.0.0.1:3000/articles //delete请求 curl -X DELETE http://127.0.0.1:3000/articles/0 效果和postman很像，但是在返回结果的显示上，postman有更好的优化。 有关curl详细的参数说明可以点击这里 ejsejs是一种嵌入式javascript模版引擎，用来编写模版。 常见的模版引擎有jsp、ejs、… 这个示例中使用到的是ejs，因为ejs使用到的语言是javascript，比较容易上手。 原书中的示例代码清单3-6列表模版我在测试中无法正常使用，需要修改含有include的那一行代码，具体如下 //3-6修改后的版本 //articles.ejs &lt;%- include (&#39;./head&#39;) %&gt; &lt;ul&gt; &lt;% articles.forEach(article =&gt; { %&gt; &lt;li&gt; &lt;a href=&quot;/articles/&lt;%= article.id %&gt;&quot;&gt; &lt;%= article.title %&gt; &lt;/a&gt; &lt;/li&gt; &lt;% }) %&gt; &lt;/ul&gt; &lt;%- include (&#39;./foot&#39;) %&gt; 我看代码后的总结： &lt;%= xxx %&gt;:用来表示xxx为一个变量 &lt;%- include (‘相对路径’) %&gt;:用来引入一个外部文件填充此处 &lt;% 脚本语言 %&gt;:书写脚本语言，用于流程控制 官网给出的标签含义： &lt;% 脚本标签，用于流程控制，无输出 &lt;%_/_%&gt;删除其前面/后面的空格符 &lt;%=输出数据到模版（转义HTML标签） &lt;%-输出数据到模版（非转义） &lt;%#注释标签，不执行，不输出内容 &lt;%%输出字符串‘&lt;%’ -%&gt;删除紧随其后的换行符 以上是ejs的标签含义 ejs在express中的引用express提供一种方式，可以支持多个格式，res.format，示例如下： res.format({ html: ()=&gt;{ res.render(&#39;articles.ejs&#39;,{articles: articles}); }, json: ()=&gt;{ res.send(articles) } }) res.format根据请求发送相应格式的响应。 这里我尝试了几种写法，依然无法响应到其他的格式","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"},{"name":"node","slug":"FE/node","permalink":"http://yoursite.com/categories/FE/node/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"node的修行--第二天","slug":"node的修行--第二天","date":"2020-11-06T08:58:25.647Z","updated":"2020-11-11T02:17:07.868Z","comments":true,"path":"2020/11/06/node的修行--第二天/","link":"","permalink":"http://yoursite.com/2020/11/06/node%E7%9A%84%E4%BF%AE%E8%A1%8C--%E7%AC%AC%E4%BA%8C%E5%A4%A9/","excerpt":"","text":"node的修行–第二天 nodejs实战（第二版） exports和module.exports在node中默认导出的是module.exports，也就是说在同一个文件下如果同时使用exports和module.exports，那么只有module.exports生效。 换个角度解释就是，exports是module.exports的引用， exports格式：exports.[alias] = [属性名或方法名或其本身] 只能通过.运算符，向exports对象上添加方法或属性，从而导出方法或属性值，无法导出其他类型的值。 示例： // fun.js const str = &#39;this is str&#39;; function fun(){ console.log(&#39;this is fun&#39;); } exports.fun = fun; exports.str = str; //app.js const fun = require(&#39;./fun&#39;); console.log(fun.str);// this is str console.log(fun.fun());// this is fun 这里需要注意一点：绝对不能直接给exports赋值，那样返回时只会导出一个空的对象，这是因为默认返回的是module.exports，而直接给exports赋值则修改了exports的指向，此时module.exports还是一个空的对象。 module.exports可以直接赋值任何类型的值，也可以像exports一样，通过.运算符进行赋值，通常会选择到处一个有若干方法和属性的对象。 示例： //fun.js const str = &#39;this is str&#39;; function fun(){ console.log(&#39;this is fun&#39;); } module.exports = { fun: fun, str: str } //test_fun.js const fun = require(&#39;./fun&#39;); fun.fun();//this is fun console.log(fun.str);//this is str 注意：如果在同一个文件下，对module.exports重复赋值，则以最后一个为准。 引用require在上面的示例中已经有所展示，如果返回的是一个对象，那么可以通过.操作符进行对对象属性的引用。 除此之外，还有一种引用方式： //test_fun.js const {fun,str} = require(&#39;./fun&#39;); fun();//this is fun console.log(str);//this is str 这里使用的是ES6中的解构赋值，可以直接引用，不需要以对象属性的方式调用。 待补充 export 和 export default","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"},{"name":"node","slug":"FE/node","permalink":"http://yoursite.com/categories/FE/node/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"call、bind和apply浅析","slug":"call、bind和apply浅析","date":"2020-11-06T01:56:12.890Z","updated":"2020-11-11T03:25:57.404Z","comments":true,"path":"2020/11/06/call、bind和apply浅析/","link":"","permalink":"http://yoursite.com/2020/11/06/call%E3%80%81bind%E5%92%8Capply%E6%B5%85%E6%9E%90/","excerpt":"","text":"call、bind和apply浅析 以下三个方法可以修改this call格式：call(this,arg1,arg2,…) 第一个参数指定this的指向，从第二个参数开始就是新添加的函数参数 bind格式：bind(this,arg1,arg2,…) 生成一个新的函数，第一个参数作为新的函数的this指向，之后的参数作为函数参数传入新的函数中。 也是因为这个，所以调用bind后无法自动运行，必须手动运行才可以 apply格式：apply(this,[arg1,arg2,arg3,…]) apply方法和call方法的参数很像，apply只有两个参数，第二个参数表示为一个参数列表，而在call方法中，是一个个的参数。 特殊用法[].slice.call(arguments) 可以将类数组转换为真正的数组 类数组：具有length属性的对象等 slice这里我们回顾下数组的方法slice： slice方法用于浅复制原数组的片段，不会改变原数组，返回截取片段 .slice(start,end)返回 [start,end)的值，注意这里不包括end值，如果不传入参数，则默认返回与原数组相同的数组。 var arr = [&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;]; console.log(arr.slice(0,2));//[&#39;1&#39;,&#39;2&#39;] console.log(arr.slice(1,2));//[&#39;2&#39;] console.log(arr);//[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;,&#39;5&#39;] 测试通过数组prototype中的方法slice，可以将类数组中的值浅复制到一个真正的数组中，因为原类数组无法使用slice方法，所以通过call方法进行调用，返回结果数组。 var obj = { length: 8 }; var arr = [].slice.call(obj); console.log(arr);//[&lt;8 empty items&gt;] console.log(typeof arr);//Array console.log(typeof obj);//Object 此示例中将一个具有length属性的对象转换为了数组，可以使用数组下的所有方法。 常用案例1.将传入函数的参数转换为数组a. [].slice.call() 这里我们知道，函数默认有一个参数arguments用来保存传入的参数，但是他不是真正的数组，而是类数组，除了索引和length属性之外的其他方法都无法使用，这时就可以使用此方法进行转换，以下示例： function test(a,b,c){ console.log(arguments[0]);//1 console.log(arguments.length);//4 //console.log(arguments.push(4));//Error: push is not a function var arr = [].slice.call(arguments); arr.push(5); console.log(arr);//[1,2,3,4,5] } test(1,2,3,4) b. Array.apply() function test(a,b,c){ var arr = Array.apply(null,arguments); arr.push(5); console.log(arr);//[1,2,3,4,5] } test(1,2,3,4) 这里使用了Array的构造函数，通过apply方法，将类数组arguments作为apply方法的第二参数（参数数组）传入Array的构造函数，创建一个数组。 c. Array.from() function test(){ var arr = Array.from(arguments); arr.push(5); console.log(arr);//[1,2,3,4,5] } test(1,2,3,4); d. […arguments]","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"},{"name":"Function","slug":"FE/Function","permalink":"http://yoursite.com/categories/FE/Function/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"Function","slug":"Function","permalink":"http://yoursite.com/tags/Function/"}]},{"title":"记formidable模块的坑","slug":"记formidable模块的坑","date":"2020-11-01T11:57:37.241Z","updated":"2020-11-06T02:00:47.833Z","comments":true,"path":"2020/11/01/记formidable模块的坑/","link":"","permalink":"http://yoursite.com/2020/11/01/%E8%AE%B0formidable%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9D%91/","excerpt":"","text":"记formidable模块的坑formidable下载以及使用方式在npmjs中有着详细的展示，这里就不一一叙述了。 遇到的坑 这里记录下使用formidable时，遇到的坑以及解决方式 enctypeform标签中有enctype属性，表示表单传输数据的格式，一般有以下三种属性值： mutipart/form-data：传输文件时设置（type=’file’） text/plain：html5新加的属性值 application/x-www-form-urlencoded：默认设置的值 nameinput标签上有个name属性，当我第一次见到它时，学长就一直强调name属性的重要性，我只是每次都写，但并没有明白其中的原因，当我这次使用formidable模块并上传一张图片时，出现了一个小bug：获取的fields和files值都是空对象，查错后发现是name属性没有设置的缘故。 后端通过name属性获取到表单中发送的值","categories":[{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"},{"name":"模块","slug":"node/模块","permalink":"http://yoursite.com/categories/node/%E6%A8%A1%E5%9D%97/"}],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"模块","slug":"模块","permalink":"http://yoursite.com/tags/%E6%A8%A1%E5%9D%97/"},{"name":"formidable","slug":"formidable","permalink":"http://yoursite.com/tags/formidable/"}]},{"title":"mongoDB--安装运行","slug":"mongoDB--安装运行","date":"2020-10-23T00:37:24.409Z","updated":"2020-11-06T02:08:31.961Z","comments":true,"path":"2020/10/23/mongoDB--安装运行/","link":"","permalink":"http://yoursite.com/2020/10/23/mongoDB--%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C/","excerpt":"","text":"mongDB–安装运行 安装过程有些“离奇”，记录下安装过程 安装前期准备 在官网下载tgz安装包，这里选择好版本以及本机的系统 [ BkgxL8.png](https://s1.ax1x.com/2020/10/23/BkgxL8.png) 下载好后解压 [ Bk2FWn.png](https://s1.ax1x.com/2020/10/23/Bk2FWn.png) 在想要放置mongodb的地方创建一个mongodb的文件夹，将解压后的文件夹移入其中，并在新创建的mongodb文件夹下创建一个名为db的文件夹，如下图： [ Bk2rlt.png](https://s1.ax1x.com/2020/10/23/Bk2rlt.png) 前期工作已经准备好了，接下来就是配置环节： 配置 打开命令行工具，cd到mongodb/mongodb…./bin下，使用pwd获取到bin所在的完整路径 [ Bk2fYj.png](https://s1.ax1x.com/2020/10/23/Bk2fYj.png) 将获取到的路径写入~/.bash_profile [ Bk2WkQ.png](https://s1.ax1x.com/2020/10/23/Bk2WkQ.png) 写好后，在命令行中输入source ~/.bash_profile，使改动生效 运行cd到bin目录下，运行./mongod --dbpath db文件夹路径，如果看到有”Listening on”,”attr”:{“address”:”127.0.0.1”}还有端口27017则开启成功，在浏览器中输入127.0.0.1:27017可以看到 It looks like you are trying to access MongoDB over HTTP on the native driver port.重新打开一个终端，刚刚的运行不要关闭，刚刚的运行不要关闭，刚刚的运行不要关闭，cd到bin目录下，运行./mongo，这里就可以开始操作数据库了 自启动上述过程中是手动启动，下面通过launchctl来进行自启动的设置 在终端中输入命令：sudo vim /Library/LaunchDaemons/org.mongo.mongod.plist，创建一个文件，进行代码编写，他会在计算机启动时运行 在里面粘贴一下内容，需要修改三处路径 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt; &lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;org.mongo.mongod&lt;/string&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/local/bin/mongod&lt;/string&gt; &lt;string&gt;--dbpath&lt;/string&gt; &lt;string&gt;/var/lib/mongodb/&lt;/string&gt; &lt;string&gt;--logpath&lt;/string&gt; &lt;string&gt;/var/log/mongodb.log&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/plist&gt; &lt;string&gt;/usr/local/bin/mongod&lt;/string&gt;这里时mongod的绝对路径 &lt;string&gt;--dbpath&lt;/string&gt;&lt;string&gt;/var/lib/mongodb/&lt;/string&gt;这里是db路径，db是mongodb数据库存储的地方，默认是没有的，需要自己创建 &lt;string&gt;--logpath&lt;/string&gt;&lt;string&gt;/var/log/mongodb.log&lt;/string&gt;同第二个，是log日志文件 运行一下命令： sudo chown root:wheel /Library/LaunchDaemons/org.mongo.mongod.plist sudo launchctl load /Library/LaunchDaemons/org.mongo.mongod.plist sudo launchctl start org.mongo.mongod 此时重启即可 Navicat上述过程中使用的都是terminal，用命令行对数据库进行操作，接下来安装navicat图形化管理数据库。 [ BVR76A.png](https://s1.ax1x.com/2020/10/24/BVR76A.png) 使用新建连接，直接连接相对应的数据库。 参考 在MaxOS X中如何让MongoDB在开机时自动启动 mac下的mongoDB的安装和启动","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"数据库","slug":"后端/数据库","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mongDB","slug":"mongDB","permalink":"http://yoursite.com/tags/mongDB/"}]},{"title":"认识promise","slug":"认识promise","date":"2020-10-15T07:30:15.792Z","updated":"2020-11-06T02:03:21.582Z","comments":true,"path":"2020/10/15/认识promise/","link":"","permalink":"http://yoursite.com/2020/10/15/%E8%AE%A4%E8%AF%86promise/","excerpt":"","text":"认识Promise Promise将异步操作变为同步操作，避免回调函数的层层嵌套引起的callback hell 前言在一些需求中，很常见需要用到回调的地方，例如在充话费时，需要先通过电话号码查询到所处的地区，然后再根据地区去返回可以充值的话费额度，如果用callback+ajax(jquery)来写这个需求的话： function success(response){ console.log(&#39;success:&#39;+response); } function fail(e){ console.log(&#39;error:&#39;+e); } function getAjax(method,url,data,success,fail){ $.ajax({ url: url, method: method, data: data, dataType: &#39;json&#39;, success: success, fail: fail }) } var phoneNum = &#39;12345&#39;; getAjax(&#39;get&#39;,&#39;/getCity&#39;,phoneNum,function(city){ getAjax(&#39;get&#39;,&#39;/getMoney&#39;,city,success,fail); },fail); 可以看出，虽然对ajax请求以及回调函数(success,fail)进行了封装，但错误处理不是方便，如果再多几个嵌套，那可真成了callback hell。而promise使得异步操作可以像同步操作一样去书写，并且会提供.catch() 错误处理。 Promisepromise有三种状态： pending（待定） fulfilled（成功） rejected（失败） promise中文含义表示是承诺，承诺xx事件会在未来某个时刻完成，在promise中，状态只能由promise异步请求的结果所改变，并且只有两种： pending-&gt;fulfilled Pending-&gt;rejected 新建一个promise：var example = new Promise((resolve,reject)=&gt;{})，Promise构造函数中传入一个参数为resolve，reject的函数，当异步请求成功则执行resolve，失败则执行reject。 方法以及用例.then([resolve],[reject])用于处理异步请求后promise的不同状态下的操作，通过链式的方式进行请求后的一些操作，解决了回调函数所带来的回调地狱问题，示例如下： let promise = readFile(&#39;./example.js&#39;); promise.then(()=&gt;{ console.log(&#39;readFile successful&#39;); }).then(()=&gt;{ ...进而对获取到的内容继续操作 }) .catch()错误处理，相当于.then(null,(e)={console.log(e)})，只处理状态是错误的情况，用法和.then也一样，链式的写在promise的最后即可。 通常情况下，.then常用于处理状态正确时，而在最后使用.catch对错误进行抓取 常用方法.all()用法：.all([promise1,promise2,promise3,…]) 只接受一个参数，参数为一个可迭代对象，只有当可迭代对象中所有的promise都完成后返回的promise才会完成。 返回的promise状态: 取决于可迭代对象中所有返回promise的状态，如果有一个rejected，那么就是rejected，所有的都是fulfilled，promise返回fulfilled。 可迭代对象 数组、类数组等的数据类型。 .finally()不论promise的状态是什么（pending-&gt;fulfilled或者pending-&gt;rejected），都会执行。 .resovle()promise.resolve()可以将一个其他类型的值转换为promise，并且状态为resolve 当传入参数是数字、字符串、对象等时，返回promise，.then()中的行参res接受了传入的参数 let pro = Promise.resolve(666); console.log(pro)//Promise{666} pro.then((res)=&gt;{ console.log(res);//666 }) 当传入的参数是一个promise，则直接返回 参数为thenable thenable对象，具有.then()方法，并且可以接受resolve，reject参数的对象，称为thenable对象 var thenableExample = { then: function(resolve,reject){ resovle() } } .reject()用法和resolve一样，只不过返回的promise的状态是rejected，.resolve可以用.then()来接受参数，同理reject可以使用.catch()来接受 let promiseReject = Promise.reject(666); promiseReject.catch((e)=&gt;{ console.log(e);//666 }) .race()可以传入多个promise，返回的promise状态取决于最快执行完的promise。 这里有一点，不太明白 var f1 = new Promise((resolve,reject)=&gt;{ setTimeout(resolve(&#39;f1&#39;),500); }); var f2 = new Promise((resolve,reject)=&gt;{ setTimeout(reject(&#39;f2&#39;),100); }); var promise = Promise.race([f1,f2]); promise.then(result=&gt;console.log(result)) .catch(e=&gt;console.log(e));上述代码中，如果按照谁先执行完取谁的状态，那么最后应该是输出f2，但是无论怎么修改setTimeout的delay值，都不会对结果有任何改变，一直输出f1，当改变.race中参数的位置后，输出也变为了f2 在经过一些尝试后，发现，当setTimeout的写法改为setTimeout(resovle,500,&#39;f1&#39;)时，结果和.race预计输出的结果一样。","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"}]},{"title":"api+vutrl服务器搭建","slug":"api服务器搭建","date":"2020-10-07T06:50:00.853Z","updated":"2020-11-06T02:07:19.062Z","comments":true,"path":"2020/10/07/api服务器搭建/","link":"","permalink":"http://yoursite.com/2020/10/07/api%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/","excerpt":"","text":"api+vutrl服务器搭建 在最近学习过程中，找到了个好玩的网站，他会提供免费的api进行测试练习（ 跳转查看），在后来要个可以获取到歌曲的接口，在查找后，发现了网易云音乐api、QQ音乐api，在下面演示中使用到的是qq音乐api 前期准备需要有一个服务器，当然任何平台的都可以，这里我使用的是vutrl。 购买服务器 下载一个ftp软件，用来连接远程服务器并互传文件 下载xshell等可以连接远程服务器的软件，用来通过命令对服务器进行操作 部署 使用git下载项目，解压 git clone git@github.com:jsososo/QQMusicApi.git 通过ftp软件连接远程服务器 将整个项目放入根文件夹下（/root/） 使用xshell进行连接远程服务器，执行以下命令 首先运行项目需要先安装nodesudo yum install epel-release sudo yum install nodejs 进入到项目文件夹下运行项目ls //通过ls查看当前目录下文件 cd QQMusicapi //转到api项目下 npm install //下载依赖 npm start //运行项目 到这里大部分的部署工作已经完成，但是当访问时还是不行，这是因为虽然对应端口开启了服务，但是对外并没有开启服务，需要以下步骤进行开启端口 这里需要注意，修改后端口开关状态后，一定要重启防火墙，一定要重启防火墙，一定要重启防火墙 //查看3300端口是否开启（yes/no） firewall-cmd --query-port=3300/tcp --zone=public //开启3300端口 firewall-cmd --zone=public --add-port=3300/tcp --permanent //重启防火墙 firewall-cmd --reload开启对应的端口，并重启防火墙后，进行开启服务，此时可以正常使用了 后台运行前面实现了手动运行，但是断开连接后，接口就无法使用了，这时就需要后台一直运行这个进程 这里使用到screen 连接远程服务器后，输入screen命令，如果找不到命令的话需要下载 yum install screen安装好后，输入screen -S yourname，这时会打开一个窗口，在这里进入到项目文件夹下，通过npm start运行项目，此时关闭连接即可","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"},{"name":"api","slug":"FE/api","permalink":"http://yoursite.com/categories/FE/api/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"api","slug":"api","permalink":"http://yoursite.com/tags/api/"}]},{"title":"在Mac上配置apache，mysql，php的环境","slug":"在mac中配置apache、mysql、php ","date":"2020-09-27T01:09:52.759Z","updated":"2020-11-06T02:04:46.783Z","comments":true,"path":"2020/09/27/在mac中配置apache、mysql、php /","link":"","permalink":"http://yoursite.com/2020/09/27/%E5%9C%A8mac%E4%B8%AD%E9%85%8D%E7%BD%AEapache%E3%80%81mysql%E3%80%81php%20/","excerpt":"","text":"在Mac上配置apache，mysql，php的环境 版本：MacOS Catalina 10.15.6 mac系统一般自带apache和php，只需要简单命令开启即可 apachesudo apachectl start; //开启apahce服务 sudo apachectl restart; //重启apache服务 sudo apahcectl stop; //关闭apache服务当开启apache服务后，打开浏览器输入：localhost如果出现It Works!表示成功开启服务。 0FL1Gn.jpg php开启php，需要修改apache的配置文件，将php模块启用 在终端中输入sudo vim /etc/apahce2/httpd.conf 查找以LoadModule php...开头的一句，去掉前面的#（#为注释作用） 修改完后保存退出（esc&gt;:wq&gt;回车） 这里我们需要修改默认的apahce文件夹目录，原来默认的文件夹在/Library/WebServer/Documents，该目录是隐藏的，操作不方便，自定义一个文件夹，修改默认路径指向 在终端中输入sudo vim /etc/apache2/httpd.conf 找到以下两行 DocumentRoot &quot;Library/WebServer/Documents&quot; &lt;Directory &quot;Library/WebServer/Documents&quot;&gt; 将上述两行中双引号中的路径修改为自定文件夹的路径并保存 重启apache服务（sudo apacheclt restart） 在自定义文件夹中新建文件index.php，内容如下： &lt;?php phpinfo()?&gt; 打开浏览器，输入localhost/index.php，如果出现的是php的相关信息页面，恭喜成功。 mysql最后我们开始mysql的安装配置 在终端中输入brew install mysql,坐等安装完成即可 成功安装后，在终端中输入mysql -u root，初始状态默认是没有密码的 进入后可以通过以下命令来进行设置root用户密码 use mysql; alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password by &#39;你的密码&#39;; flush privileges; 设置完成后quit，重新登陆测试是否成功 phpmyadmin安装好mysql后，在phpMyAdmin官网中下载，下载好后解压，重命名为phpmyadmin，移动到自定义文件夹下，在浏览器中输入localhost/phpadmin/可以看到以下登陆界面，使用root用户登陆即可 0FLRde.png 如果登陆不进去有可能是配置文件的问题，打开phpmyadmin文件夹下的config.inc.php文件，如果有相似的文件重命名为config.inc.php，在文件中找到以下几行并进行设置 $cfg[&#39;Servers&#39;][$i][&#39;host&#39;] = &#39;127.0.0.1&#39;; $cfg[&#39;Servers&#39;][$i][&#39;controluser&#39;] = &#39;root&#39;;（这里的用户名必须为root） $cfg[&#39;Servers&#39;][$i][&#39;controlpass&#39;] = &#39;你自定的密码&#39;;","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"},{"name":"Mac","slug":"FE/Mac","permalink":"http://yoursite.com/categories/FE/Mac/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"},{"name":"环境配置","slug":"环境配置","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"}]},{"title":"node的修行--第一天","slug":"node的修行--第一天","date":"2020-09-18T01:54:01.097Z","updated":"2020-11-06T02:08:39.127Z","comments":true,"path":"2020/09/18/node的修行--第一天/","link":"","permalink":"http://yoursite.com/2020/09/18/node%E7%9A%84%E4%BF%AE%E8%A1%8C--%E7%AC%AC%E4%B8%80%E5%A4%A9/","excerpt":"","text":"node的修行–第一天 运行环境：macOS Catalina 遇到的问题：nvm、node、npm等安装后，重新打开terminal执行时报command not found解决方法 前言 补充一些新姿势，可以 nvmnvm（nodejs version manger），nodejs的版本管理，可以很轻松的下载、切换不同版本的nodejs，对于不同的项目需求可以进行快速切换运行项目。 npmnpm（nodejs package manger），nodejs包管理器，方便使用者对于一些包的下载使用。 shellShell是linux系统下的交互式工具，可以帮助用户启动程序，管理文件以及运行的进程。 在mac中可以打开terminal使用shell命令 可以在terminal中输入echo $SHELL查看系统默认shell是什么版本（在最新的catalina上，shell版本为zsh），如果需要更换可以参考官网链接。 正文在跟着教程安装配置好nvm后，当我重新打开一个terminal准备开始第一个练手项目时发现，输入nvm、node、npm等都直接给出command not found: xxx，这让我有点摸不着头脑，明明安装成功了，为什么无法使用呢，经过查找后才了解到，这里缺失了很重要的一步，那就是配置环境，没有配置环境是无法找到对应的文件的，网上有着不同的说法: 第一种是在~/.bash_prifile中添加以下两行内容（如果没有此文件，新建一个），保存后执行source ~/.bash_profile export NVM_DIR=&quot;/Users/yourname/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm第二种是在~/.bash_profile中添加以下内容： export NVM_DIR=&quot;/Users/yourname/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm [ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/bash_completion&quot; # This loads nvm bash_completion有趣的是我在第一遍尝试时，直接将给出的代码复制粘贴了进去，结果依然是不行，回过头查看给出的几行代码中才发现，有路径是写的默认路径，作者也没有明确给出提示更换路径，这里将第一行中的路径更改为&quot;$HOME/.nvm&quot;即可，再执行文件后，可以使用了，但是当我重新打开一个terminal时，问题又一次出现了，那么现在问题好解决了，只要每次都自动执行source ~/.bash_profile这行代码就可以了，那么方法就是，在~/.zshrc文件中，添加一行source ~/.bash_profile即可解决。 解决方法： 打开~/.bash_profile添加以下代码： export NVM_DIR=&quot;$HOME/.nvm&quot; [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 在terminal中输入source ~/.bash_profile 打开~/.zshrc添加一行source ~/.bash_profile ps:如果没有上述的两个文件，新建即可","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"},{"name":"node","slug":"FE/node","permalink":"http://yoursite.com/categories/FE/node/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"移动端输入法和底部的冲突解决","slug":"移动端输入法和底部的冲突解决","date":"2020-09-07T23:57:32.126Z","updated":"2020-11-06T02:04:16.689Z","comments":true,"path":"2020/09/08/移动端输入法和底部的冲突解决/","link":"","permalink":"http://yoursite.com/2020/09/08/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%BE%93%E5%85%A5%E6%B3%95%E5%92%8C%E5%BA%95%E9%83%A8%E7%9A%84%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3/","excerpt":"","text":"移动端输入法和底部的冲突解决 在用原生写一个移动端的app时，遇到了一个问题，在设置了一个搜索栏的同时页面底部有导航栏，并且点击搜索栏输入并没有跳转到其他页面，结果在测试输入时发现底部导航栏出现在了输入法的上方 分析原因我猜想是窗口大小改变了，从原来的大视图缩小为小视图+键盘大小，给导航栏设置的position: fixed;bottom: 0;也确实还生效，只不过显示屏大小改变了。 尝试解决window.onresize可以监听窗口大小变化，如果窗口大小变化则调用函数，示例如下： window.onresize = function(){ alert(1); } 如果只是判断窗口大小改变可能还不足够确定是不是输入法的出现导致的，为了确保是，那么还需要加一个判断，判断当前的视图高度比之前的低即可 var oldHeight = window.screen.height; window.onresize = function(){ var currentHeight = window.screen.height; if(currentHeight&lt;oldHeight){ alert(1); } } 现在可以判断出，此时输入法导致了屏幕视图大小的改变，那么如何修改导航栏呢，这里需要重新看一看position的各个值的含义： 在上面可以看出，此时其实只要把导航栏移出我们的视线即可，这样方法就变多了，你可以使用absolute定位或者fixed将它移出视图外，也可以把position的属性改为static、relative都可以 结论解决方法： 检测到视图大小变化了后， 使用absolute定位或者fixed将它移出视图外 或者直接将position的属性改为static或者relative ps：这让我想起了之前学习建网站时，logo图标是显示在视图内的，但logo图标的文字是设置在了视图之外，好像是为了搜索此网站时，增加匹配值。","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"mobile terminal","slug":"mobile-terminal","permalink":"http://yoursite.com/tags/mobile-terminal/"}]},{"title":"正则表达式自测及总结","slug":"正则表达式","date":"2020-09-07T09:53:12.350Z","updated":"2020-11-06T02:06:14.397Z","comments":true,"path":"2020/09/07/正则表达式/","link":"","permalink":"http://yoursite.com/2020/09/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式 以下测试使用的网站为：regex101 前文正则表达式在处理文件，验证表单信息时常常使用，你是否也在使用它的时候不管它的意思，只要百度到能用的就用了，虽然在使用上可能不会遇到什么问题，但是当你理解了其中的意思，在看现成的代码时可以进行学习以及修改，让他可以无限的符合自己的需求，何乐而不为呢。 正则表达式在js中使用的是RegExp类型来支持正则表达式 语法：var expression = /pattern/flags flags(标志)：一个表达式可以包含一个或多个flags pattern(模式)：可以包含字符、限定符、分组、反向引用、向前查找 flags /g：全局模式 /m：多行模式 /i：不区分大小写 pattern： /xxx/: 直接匹配xxx /[0-9]/: 可以匹配0-9的某个数字（[]方括号内是某个范围匹配例如[0-9]、[a-z]） /[0-9]*/: 可以匹配零个或多个数字（星号表示零个或多个） /^[0-9]/: 可以匹配非数字（^表示非，否定） /[1|2]/: 可以匹配1或者2（｜表示或者） /./: 可以匹配单个任意字符 /a?/: 可以匹配零个或一个a /[0-9]+/: 可以匹配一个或者多个数字（+表示一个或多个） /3{4}/: 可以匹配四个连续的3 /3{4,}/: 可以匹配四个或者四个以上的3 /3{4,6}/: 可以匹配四个到六个连续的3 /^xxx$/: 开头^ 结尾$ /aaa(?=bbb)/: 正向肯定预查，匹配aaabbb中的aaa /aaa(?!bbb)/: 正向否定预查，匹配除了aaabbb中的aaa其余的aaa /(?&lt;=aaa)bbb/: 反向肯定预查，匹配aaabbb中的bbb /(?&lt;!aaa)bbb/: 反向否定预查，匹配除了aaabbb中的bbb其余bbb 一下是一些常见的替换的字符： \\s：空白 \\S：非空白 \\d：阿拉伯数字 \\D：非阿拉伯数字 \\w：字母、数字或下划线 \\W：非字母、数字或下划线 \\b：字符边界 \\B：非字符边界 小测试这里有几个需求，可以进行学习的检测，在输入框内输入设计好的正则表达式，在后面的测试框内输入想要测试的数据，判断是否正确。（以下方法都不唯一，也可以自己在测试网站regex101上测试） 在一群妖怪中救出唐僧(1.直接匹配唐僧2.匹配除唐僧外所有的妖怪，这里不要忘记“妖怪”后面带的字母或者数字) 测试数据：妖怪A妖怪A妖怪1妖怪A妖怪A妖怪C妖怪A妖怪A妖怪A妖怪A妖怪A妖怪A妖怪A妖怪Y妖怪A妖怪Y妖怪T妖怪R妖怪E妖怪A妖怪A妖怪B妖怪D唐僧妖怪A妖怪C妖怪A妖怪A妖怪A妖怪A妖怪G妖怪A妖怪A妖怪V妖怪A妖怪A妖怪A妖怪U妖怪A妖怪A妖怪A妖怪A妖怪A妖怪C妖怪A妖怪C妖怪A妖怪A妖怪A妖怪A妖怪A 换源，下面有一段视频链接，需要将其中的CN进行更换为HK，对于需要更换的CN进行匹配，请设计出相对应的正则表达式使之成功换源 原链接（目前没有找到可以换源的测试链接，这个是个假链接）：https://log2.musical.ly/service/2/app_log/?version_code=10.8.1&amp;pass-region=1&amp;pass-route=1&amp;language=zh&amp;app.name=musical_ly&amp;vid=37111EC4-2618-4BD3-BD30-39324B52F6FB&amp;app_version=10.8.1&amp;carrier_region=CN&amp;is_,my_cn=1&amp;channel=App%20Store&amp;mcc_,mnc=46000&amp;device_id=6645470638472295942&amp;tz_,offset=288,00&amp;account_region=KR&amp;sys_region=CN&amp;aid=1233&amp;screen._width=750&amp;uoo=0&amp;openudid=4a5bbbd1eCN9c660f3a793f2cada5f315309571e&amp;os_,api=18&amp;ac=WIFI&amp;os_version=12.1.4&amp;app,_language=zh-Hant&amp;tz_name=Asia/CNShanghai&amp;device_platform=iphone&amp;build_CN,number=108101&amp;device_,type=iPhone9,1&amp;iid=6679029519735613909&amp;idfa=DB32F26F-616F-1264-9674-D6ED5119A072&amp;mas=01a2346c93daaf7f7ff09020c0aabd6fc9b6ed007d5fb843130f 提示：不是所有CN都要替换，只有以_region=开头以&amp;结尾的CN需要更换 设计一个电话号码的正则表达式，用于测试用户是否输入了正确的电话号码格式 要求：手机号大家应该都了解，这里不过多介绍 设计一个邮箱账号的正则表达式，用于测试用户是否输入了正确的邮箱账号格式 同手机号 好啦，到这里，百分之八十的正则表达式就已经可以看懂了，网上还有很多大佬写的正则表达式可以更好的匹配以及在实际应用中使用，多学多看。","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"},{"name":"正则","slug":"FE/正则","permalink":"http://yoursite.com/categories/FE/%E6%AD%A3%E5%88%99/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"ajax前后端数据交互","slug":"ajax前后端数据交互","date":"2020-09-04T16:49:35.516Z","updated":"2020-11-06T02:07:25.578Z","comments":true,"path":"2020/09/05/ajax前后端数据交互/","link":"","permalink":"http://yoursite.com/2020/09/05/ajax%E5%89%8D%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/","excerpt":"","text":"ajax前后端数据交互 通过一次和后端的对接，记录一下学习到的知识点，项目中我使用的是jquery，原因会在后面说到。 使用原生js来设置ajaxvar xhr = null; if(window.XMLHttpRequest){//判断当前浏览器是否支持XMLHttpRequest() xhr = window.XMLHttpRequest(); }else{//IE5,IE6 xhr = window.ActiveXObject(&#39;Microsoft.XMLHttp&#39;); } xhr.open(&#39;get&#39;,&#39;xxx&#39;,false);//设置请求信息 xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);//设置请求头信息 xhr.send();//发送请求（可以添加参数） xhr.onreadystatechange = function(){//检测响应状态码 if(xhr.readystate === 4 &amp;&amp; xhr.status === 200){//响应成功 var result = xhr.responseText; //获取服务器的响应内容 } } ps： 一、readystate:状态值（0～4）表示的是ajax请求过程到了哪一步的标志，与是否请求成功无关 0:初始化 1:开始发送请求 2:请求发送成功 3:开始接受服务端响应 4:完成响应 二、Status:Http状态码 1xx：信息响应类 2xx：处理成功类 3xx：重定向响应类 4xx：客户端错误 5xx：服务端错误 Eg：以下列举一些常见的响应状态码： 200：交易成功 403：请求不允许 404：在当前url未找到资源 500:服务器内部错误 jquery中的ajax$(function(){ $.ajax({ url: &quot;xxx&quot;,//后端提供的接口地址 async: true,//是否异步（主要看请求的资源是否会影响后面的操作来进行选择） dataType: &quot;json&quot;,//前端传给后端数据的格式，一般来说都会是一个json格式的数据 data: user,//前端传给后端的数据 success: function(data){//这里的success是在ajax请求完成后触发的，function参数里的data是后端返回的数据 if(data == &#39;false&#39;){//用于判断这一次的ajax请求是否成功 alert(&#39;失败&#39;); }else{ alert(&#39;成功&#39;); } } }) }) jquery对于ajax进行了很好的封装，可以从使用上可以看得出，上手很快，参数也是一目了然，接下来可以一起来看看jquery是如何封装ajax的。 jquery封装下的ajax 待更新","categories":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"},{"name":"ajax","slug":"FE/ajax","permalink":"http://yoursite.com/categories/FE/ajax/"}],"tags":[{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"}]},{"title":"更换电脑后博客的相关设置","slug":"更换电脑后博客设置","date":"2020-08-07T07:44:42.488Z","updated":"2020-11-06T02:05:31.260Z","comments":true,"path":"2020/08/07/更换电脑后博客设置/","link":"","permalink":"http://yoursite.com/2020/08/07/%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E5%90%8E%E5%8D%9A%E5%AE%A2%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"博客迁移 有原来的文件，只需要在新电脑上进行部署即可 大概步骤 生成并添加ssh部署密钥 Macos 打开终端输入ls -al ~/.ssh,查看目录下是否有id_rsa和id_rsa.pub文件，如果有则说明已经存在ssh密钥，直接打开文件进行复制即可 上面步骤如果没有两个文件，则需要进行生成，在终端中输入ssh-keygen -t rsa -C &quot;自己的Email地址&quot; 生成后，在终端中输入cat ~/.ssh/id_rsa.pub查看ssh密钥 最后打开github&gt;setting&gt;ssh中进行添加部署密钥即可 配置hexo、git、node等 在本地博客文件夹下打开终端，在终端中依次输入npm install hexo、npm install、npm install hexo-deployer-git npm速度可能较慢，可以进行换源，也可以下载cnpm代替npm进行下载 部署完成，之后就可以进行hexo g -d进行部署博文了","categories":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"在hexo博客中嵌入codepen","slug":"hexo+codepen","date":"2020-07-27T01:01:28.000Z","updated":"2020-11-06T02:07:57.738Z","comments":true,"path":"2020/07/27/hexo+codepen/","link":"","permalink":"http://yoursite.com/2020/07/27/hexo+codepen/","excerpt":"","text":"在hexo博客中嵌入codepen 在以往记录时，使用的都是纯代码加上效果图，但是不怎么方便好用，这里尝试使用codepen进行代码的演示。 方式一一、在codepen中创建一个账户 二、创建一个Pen，编写完成后进行保存 三、在右下角找到Embed，点击后拉到最下面选择iframe，html都可以（一定要保存后才会出现） 四、直接将代码粘贴到hexo博客中即可显示 这是使用iframe进行渲染的： See the Pen LYNegXE by cactus1949 (@cactus1949) on CodePen. 这是html代码进行渲染的： See the Pen LYNegXE by cactus1949 (@cactus1949) on CodePen. 方式二 安装官方的插件，用官方提供的语法进行插入 一、安装官方的插件npm install hexo-codepen --saveyarn add hexo-codepen 如果运行完yarn add hexo-codepen报错，可能是没有安装yarn包管理的插件，可以运行npm install yarn -g进行安装 wuynCd.png 二、用法待更新 感觉直接使用生成的代码就可以，官方的插件还不会使用，见谅，如果有使用过的可以教教我具体的操作。","categories":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"},{"name":"codepen","slug":"blog/codepen","permalink":"http://yoursite.com/categories/blog/codepen/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"codepen","slug":"codepen","permalink":"http://yoursite.com/tags/codepen/"}]},{"title":"markdown常用格式一览","slug":"md格式","date":"2020-07-27T01:01:28.000Z","updated":"2020-11-06T02:08:12.523Z","comments":true,"path":"2020/07/27/md格式/","link":"","permalink":"http://yoursite.com/2020/07/27/md%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"常用markdown语法一览 记录一些常用的markdown文档书写格式，以便于博客的书写，有使用到的新的语法即会更新此博客。 标题# h1 ## h2 ... ###### h6列表 无序列表``` list list``` 有序列表``` xxx xxx## 多选框 [] xxx## 超链接xxx```图片 可以使用html进行插入图片，附加内嵌css进行修饰 &lt;img src=&quot;&quot; style=&quot;&quot; alt=&quot;&quot;&gt;&lt;/ img&gt; md格式 {% image 图片链接 '文字说明' '' %}引用&gt; 这是一段引用代码段``` 这里是一段代码 这里是一段代码 ``` `这里是单行代码`","categories":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"},{"name":"markdown","slug":"blog/markdown","permalink":"http://yoursite.com/categories/blog/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]},{"title":"博客模版","slug":"模版","date":"2019-12-31T16:00:00.000Z","updated":"2020-11-06T02:05:51.309Z","comments":true,"path":"2020/01/01/模版/","link":"","permalink":"http://yoursite.com/2020/01/01/%E6%A8%A1%E7%89%88/","excerpt":"","text":"博客模版 记录下写博客的一般顺序以及博客基本格式 写博客--- title: 首页显示的大标题 date: 2020/01/01（可选，不设置会自动生成） index_img: /img/xxx.jpg(可选，首页左侧配图) banner_img: /img/xxx.jpg(文章页顶部大图) categories: - 分类1 tags: - 标签1 excerpt: 首页显示博客内容简介（添加简介方式1） --- 添加简介方式2:在需要在简介中显示的内容后添加&lt;!-- more --&gt;即可 博客部署一步到位：hexo g -d 参考fluid配置文档","categories":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"}]}],"categories":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/categories/mongodb/"},{"name":"后端","slug":"mongodb/后端","permalink":"http://yoursite.com/categories/mongodb/%E5%90%8E%E7%AB%AF/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/categories/node/"},{"name":"模块","slug":"node/模块","permalink":"http://yoursite.com/categories/node/%E6%A8%A1%E5%9D%97/"},{"name":"FE","slug":"FE","permalink":"http://yoursite.com/categories/FE/"},{"name":"node","slug":"FE/node","permalink":"http://yoursite.com/categories/FE/node/"},{"name":"服务端框架","slug":"FE/node/服务端框架","permalink":"http://yoursite.com/categories/FE/node/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Function","slug":"FE/Function","permalink":"http://yoursite.com/categories/FE/Function/"},{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"数据库","slug":"后端/数据库","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"api","slug":"FE/api","permalink":"http://yoursite.com/categories/FE/api/"},{"name":"Mac","slug":"FE/Mac","permalink":"http://yoursite.com/categories/FE/Mac/"},{"name":"正则","slug":"FE/正则","permalink":"http://yoursite.com/categories/FE/%E6%AD%A3%E5%88%99/"},{"name":"ajax","slug":"FE/ajax","permalink":"http://yoursite.com/categories/FE/ajax/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/categories/blog/"},{"name":"codepen","slug":"blog/codepen","permalink":"http://yoursite.com/categories/blog/codepen/"},{"name":"markdown","slug":"blog/markdown","permalink":"http://yoursite.com/categories/blog/markdown/"}],"tags":[{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"},{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"模块","slug":"模块","permalink":"http://yoursite.com/tags/%E6%A8%A1%E5%9D%97/"},{"name":"querystring","slug":"querystring","permalink":"http://yoursite.com/tags/querystring/"},{"name":"FE","slug":"FE","permalink":"http://yoursite.com/tags/FE/"},{"name":"koa","slug":"koa","permalink":"http://yoursite.com/tags/koa/"},{"name":"Function","slug":"Function","permalink":"http://yoursite.com/tags/Function/"},{"name":"formidable","slug":"formidable","permalink":"http://yoursite.com/tags/formidable/"},{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mongDB","slug":"mongDB","permalink":"http://yoursite.com/tags/mongDB/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"},{"name":"api","slug":"api","permalink":"http://yoursite.com/tags/api/"},{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"},{"name":"环境配置","slug":"环境配置","permalink":"http://yoursite.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"},{"name":"mobile terminal","slug":"mobile-terminal","permalink":"http://yoursite.com/tags/mobile-terminal/"},{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"},{"name":"ajax","slug":"ajax","permalink":"http://yoursite.com/tags/ajax/"},{"name":"blog","slug":"blog","permalink":"http://yoursite.com/tags/blog/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"codepen","slug":"codepen","permalink":"http://yoursite.com/tags/codepen/"},{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]}